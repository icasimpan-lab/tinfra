
The Idea:
    to have a common framework for easy publication
    of C++ objects+methods & functions through
     - HTTP
     - CLI
     - GUI

// iheader.cpp
struct IFoo {
    virtual std::string reverse(std::string) = 0;
};

// iheader.cpp
REGISTER_CALLABLE_METHOD(IFoo, "reverse", &IFoo::reverse);

// impl
class FooImpl {
    std::string reverse(std::string);
public:    
    FooImpl* FooImpl::create();
};

REGISTER_CLASS_FACTORY(IFoo, &FooImpl::create);

// integration part
main() 
{
    UltimateFactory cf;
    ServiceContainer c;
    unique_ptr<IFoo> foo(cf.create<IFoo>(/*how to pass params here*/));    
    c.add_service("reverser", foo);
    
    c.run();
}

// another idea

for functions that need services to operate like this:

PersonData get_person(DatabaseAccess& db, int person_id)
{
    return mo_select<PersonData>(db, F("select * from persons where id=%i",person_id))
}

the clue is that DatabaseAccess& is "service" like argument,
in constrast to person_id which is "pure function" argument.

The idea is that dispatcher will somehow "detect" service classes in form T&
and resolve them from context.
Other argument will be resolved to/from argument list (form, args).


